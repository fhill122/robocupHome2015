/**clear the content of Calibration.ini
 * put the scene image named Calibration.jpg under /home/robocuphome/robocuphome2015/src/vision/data/
 * then run this node
 */
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
//~ #include "../../core/src/CommonConstants.h"
#include "Constants.h"
#include "../../../path.h"

using namespace cv;
using namespace std;


/// Global variables
Mat src, src_gray;

int maxCorners = 140;
int maxTrackbar = 200;
vector<Point2f> corners;
vector<Point2f> corners_selected;

RNG rng(12345);
String source_window = "Image";
string calibration_file_string((string)PROJECT_PATH+(string)CALIBRATION_FILE);
string calibration_image_string((string)PROJECT_PATH+(string)CALIBRATION_IMAGE);


/// Function header
void goodFeaturesToTrack_Demo( int, void* );
void mouseClick(int event, int x, int y, int flags, void* userdata);

/**
 * @function main
 */
int main( int argc, char** argv ){
    cout<<"x:"<<TableBlockX<<", y:"<<TableBlockY<<"\n";
    double point5X = (double)BaseX + (double)BaseToPoint5;
    cout<<"5x:"<<point5X<<"\n";
    
    ///check file availability
    fstream file (calibration_file_string.c_str());
    if (!file.is_open()){
        printf("ERROR: Unable to open calibration file\n");
        return 2;
    }
    src = imread( calibration_image_string);
    if (src.empty()){
        printf("ERROR: Unable to load calibration image file under Data folder\n");
        return 2;
    }
    
    ///Convert source image to gray
    cvtColor( src, src_gray, CV_BGR2GRAY );
    
    /// Create Window
    namedWindow( source_window, CV_WINDOW_AUTOSIZE );
    
    /// Create Trackbar to set the number of corners
    createTrackbar( "Max  corners:", source_window, &maxCorners, maxTrackbar, goodFeaturesToTrack_Demo );
    
    /// set mouse click behavour
    setMouseCallback(source_window, mouseClick, &src);
    
    imshow( source_window, src );
    
    goodFeaturesToTrack_Demo( 0, 0 );
    
    waitKey(0);
    
    /// Write to calibration file
    if (corners_selected.size() != 6){
        printf("!!Error!! \n!!Please select 6 points!!\n");
    }
    else{
        
        file << "; Generated by calibration node\n";
        //write pixel positions
        file << "[image]\n";
        for (int i=0; i<corners_selected.size();i++){
            file << "point"<<(1+i)<<"x="<<corners_selected[i].x<<"\n";
            file << "point"<<(1+i)<<"y="<<corners_selected[i].y<<"\n";
        }
       
        //write corresponding global positions
        file << "[global]\n";
        //~ printf("BaseX = %f...\n",BaseX);
        double point5X = (double)BaseX + (double)BaseToPoint5;
        double point5Y =0;
        file << "point1x="<<(point5X+3.*TableBlockX)<<"\n";
        file << "point1y="<<(point5Y+2.*TableBlockY)<<"\n";
        file << "point2x="<<(point5X+3.*TableBlockX)<<"\n";
        file << "point2y="<<(point5Y+0.*TableBlockY)<<"\n";
        file << "point3x="<<(point5X+3.*TableBlockX)<<"\n";
        file << "point3y="<<(point5Y-2.*TableBlockY)<<"\n";
        file << "point4x="<<(point5X+0.*TableBlockX)<<"\n";
        file << "point4y="<<(point5Y+2.*TableBlockY)<<"\n";
        file << "point5x="<<(point5X+0.*TableBlockX)<<"\n";
        file << "point5y="<<(point5Y+0.*TableBlockY)<<"\n";
        file << "point6x="<<(point5X+0.*TableBlockX)<<"\n";
        file << "point6y="<<(point5Y-2.*TableBlockY)<<"\n";
        printf("Calibration completed...\n");
    }
    file.close();
    return(0);
}

/**
 * @function goodFeaturesToTrack_Demo.cpp
 * @brief Apply Shi-Tomasi corner detector
 */
void goodFeaturesToTrack_Demo( int, void* )
{
  if( maxCorners < 1 ) { maxCorners = 1; }

  /// Parameters for Shi-Tomasi algorithm
  double qualityLevel = 0.01;
  double minDistance = 10;
  int blockSize = 3;
  bool useHarrisDetector = false;
  double k = 0.04;

  /// Copy the source image
  Mat copy;
  copy = src.clone();

  /// Apply corner detection
  goodFeaturesToTrack( src_gray,
               corners,
               maxCorners,
               qualityLevel,
               minDistance,
               Mat(),
               blockSize,
               useHarrisDetector,
               k );


  /// Draw corners detected
  //cout<<"** Number of corners detected: "<<corners.size()<<endl;
  int r = 4;
  for( int i = 0; i < corners.size(); i++ )
     { circle( copy, corners[i], r, Scalar(0,255,0), -1, 8, 0 ); }

  /// Show what you got
  namedWindow( source_window, CV_WINDOW_AUTOSIZE );
  imshow( source_window, copy );
}


void mouseClick(int event, int x, int y, int flags, void* userdata){
	Mat* display = (Mat*) userdata;

	if  ( event == EVENT_LBUTTONDOWN )
    {
        cout << "Left button of the mouse is clicked - position (" << x << ", " << y << ")" << endl;
        Point centre(x,y);
        circle( *display, centre, 10, Scalar(255,0,0), 3, 8, 0 );
        corners_selected.push_back(centre);
        goodFeaturesToTrack_Demo(0,0);
    }
	
}
